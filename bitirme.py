# -*- coding: utf-8 -*-
"""Bitirme.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wi-0FltQ0zUcAPrFCvih0TJj1Wu7R9Kg
"""

import numpy as np
import tensorflow as tf
from tensorflow.keras.layers import Conv1D, Dense, Flatten, MaxPooling1D
from tensorflow.keras.models import Sequential
from sklearn.model_selection import train_test_split

#maximum length for input sequence
#Sequence which will be predicted cannot be longer than this
MAX_LENGTH = 250

#Create dataset for triple zero detector
def datasetGenerator(nums, minlength=4, maxlength=MAX_LENGTH, ):
  while True:
     #Max padded dataset
    result = []
    #Labels
    y = []
        #Element length for variable sized input

    minlength = np.max([4, minlength])
    cur_length = np.random.randint(minlength, high=maxlength)
    for _ in range(nums):
      #For class selection
      randnum = np.random.rand()
      cur_data = [np.random.randint(0, high=2), np.random.randint(0, high=2)]
      if randnum>0.5:
        #There are not 3 zeros side by side in given sequence
        y.append(0)
        for i in range(2, cur_length):
          if cur_data[i-1]==0 and cur_data[i-2]==0:
            cur_data.append(1)
          else:
            cur_data.append(np.random.randint(0, high=2))
      else:
        #There are 1 triple zeros side by side in given sequence
        y.append(1)
        triplet_count = 0
        for i in range(2, cur_length):
          if triplet_count == 0:
            num_tobeadded = np.random.randint(0, high=2)
            if cur_data[i-1]==0 and cur_data[i-2]==0 and num_tobeadded==0:
              triplet_count = 1
            cur_data.append(num_tobeadded)
          else:
            if cur_data[i-1]==0 and cur_data[i-2]==0:
              cur_data.append(1)
            else:
              cur_data.append(np.random.randint(0, high=2))
          if i == cur_length-1 and triplet_count==0:
            cur_data[i-2]=0
            cur_data[i-1]=0
            cur_data[i]=0
      cur_data += [1]*(maxlength-len(cur_data))#padding   
      result.append(cur_data)
    result = np.array(result)
    result = np.expand_dims(result, axis=2)
    yield result, np.array(y)

dg = datasetGenerator(32)

vector, y = next(dg)
 y

vector.shape

#Creating 1d conv model for detecting triple zero.
model = Sequential()
model.add(Conv1D(32, kernel_size=5, input_shape=(MAX_LENGTH,1),  activation='relu'))
model.add(MaxPooling1D(2))
model.add(Conv1D(32, kernel_size=5,  activation='relu'))
model.add(Flatten())
model.add(Dense(20, activation='relu'))
model.add(Dense(1, activation='sigmoid'))
model.compile(loss='binary_crossentropy', optimizer='sgd', metrics=['accuracy'])
model.summary()

#training for 1000 
history = model.fit_generator(datasetGenerator(16),steps_per_epoch=40,epochs=500)

# Commented out IPython magic to ensure Python compatibility.
from matplotlib import pyplot as plt
import numpy as np
# %matplotlib inline
plt.style.use('classic')

x = np.linspace(1,500, 500)
plt.plot(x, history.history['acc'], '-b', label='Accuracy')
plt.plot(x, history.history['loss'], '-r', label='Loss')
plt.show()

def predict_value(inputval):
  if len(inputval)>MAX_LENGTH:
    raise Exception("Length of sequence cannot be greater than MAX_LENGTH variable")
  else:
    #Padding input
    inputval += [1]*(MAX_LENGTH-len(inputval))
    inputval = np.array(inputval)
    inputval = np.expand_dims(inputval, axis=0)
    inputval = np.expand_dims(inputval, axis=2)
    prediction = model.predict(inputval)
    return prediction

predict_value([0,1,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0])